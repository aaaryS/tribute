{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "src/Tribute.js",
    "src/TributeEvents.js",
    "src/TributeMenuEvents.js",
    "src/TributeRange.js",
    "src/TributeSearch.js",
    "src/index.js",
    "src/utils.js"
  ],
  "names": [],
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()",
    "import TributeUtils from \"./utils\";\nimport TributeEvents from \"./TributeEvents\";\nimport TributeMenuEvents from \"./TributeMenuEvents\";\nimport TributeRange from \"./TributeRange\";\nimport TributeSearch from \"./TributeSearch\";\n\nclass Tribute {\n    constructor({\n        values = null,\n        iframe = null,\n        selectClass = 'highlight',\n        trigger = '@',\n        autocompleteMode = false,\n        selectTemplate = null,\n        menuItemTemplate = null,\n        lookup = 'key',\n        fillAttr = 'value',\n        collection = null,\n        menuContainer = null,\n        noMatchTemplate = null,\n        requireLeadingSpace = true,\n        allowSpaces = false,\n        replaceTextSuffix = null,\n        positionMenu = true,\n        spaceSelectsMatch = false,\n        searchOpts = {},\n        menuItemLimit = null,\n    }) {\n        this.autocompleteMode = autocompleteMode\n        this.menuSelected = 0\n        this.current = {}\n        this.inputEvent = false\n        this.isActive = false\n        this.menuContainer = menuContainer\n        this.allowSpaces = allowSpaces\n        this.replaceTextSuffix = replaceTextSuffix\n        this.positionMenu = positionMenu\n        this.hasTrailingSpace = false;\n        this.spaceSelectsMatch = spaceSelectsMatch;\n\n        if (this.autocompleteMode) {\n            trigger = ''\n            allowSpaces = false\n        }\n\n        if (values) {\n            this.collection = [{\n                // symbol that starts the lookup\n                trigger: trigger,\n\n                // is it wrapped in an iframe\n                iframe: iframe,\n\n                // class applied to selected item\n                selectClass: selectClass,\n\n                // function called on select that retuns the content to insert\n                selectTemplate: (selectTemplate || Tribute.defaultSelectTemplate).bind(this),\n\n                // function called that returns content for an item\n                menuItemTemplate: (menuItemTemplate || Tribute.defaultMenuItemTemplate).bind(this),\n\n                // function called when menu is empty, disables hiding of menu.\n                noMatchTemplate: (t => {\n                    if (typeof t === 'function') {\n                        return t.bind(this)\n                    }\n\n                    return noMatchTemplate || function () {return ''}.bind(this)\n                })(noMatchTemplate),\n\n                // column to search against in the object\n                lookup: lookup,\n\n                // column that contains the content to insert by default\n                fillAttr: fillAttr,\n\n                // array of objects or a function returning an array of objects\n                values: values,\n\n                requireLeadingSpace: requireLeadingSpace,\n\n                searchOpts: searchOpts,\n\n                menuItemLimit: menuItemLimit,\n            }]\n        }\n        else if (collection) {\n            if (this.autocompleteMode)\n                console.warn('Tribute in autocomplete mode does not work for collections')\n            this.collection = collection.map(item => {\n                return {\n                    trigger: item.trigger || trigger,\n                    iframe: item.iframe || iframe,\n                    selectClass: item.selectClass || selectClass,\n                    selectTemplate: (item.selectTemplate || Tribute.defaultSelectTemplate).bind(this),\n                    menuItemTemplate: (item.menuItemTemplate || Tribute.defaultMenuItemTemplate).bind(this),\n                    // function called when menu is empty, disables hiding of menu.\n                    noMatchTemplate: (t => {\n                        if (typeof t === 'function') {\n                            return t.bind(this)\n                        }\n\n                        return null\n                    })(noMatchTemplate),\n                    lookup: item.lookup || lookup,\n                    fillAttr: item.fillAttr || fillAttr,\n                    values: item.values,\n                    requireLeadingSpace: item.requireLeadingSpace,\n                    searchOpts: item.searchOpts || searchOpts,\n                    menuItemLimit: item.menuItemLimit || menuItemLimit,\n                }\n            })\n        }\n        else {\n            throw new Error('[Tribute] No collection specified.')\n        }\n\n        new TributeRange(this)\n        new TributeEvents(this)\n        new TributeMenuEvents(this)\n        new TributeSearch(this)\n    }\n\n    static defaultSelectTemplate(item) {\n      if (typeof item === 'undefined') return null;\n      if (this.range.isContentEditable(this.current.element)) {\n          return '<span class=\"tribute-mention\">' + (this.current.collection.trigger + item.original[this.current.collection.fillAttr]) + '</span>';\n      }\n\n      return this.current.collection.trigger + item.original[this.current.collection.fillAttr];\n    }\n\n    static defaultMenuItemTemplate(matchItem) {\n        return matchItem.string\n    }\n\n    static inputTypes() {\n        return ['TEXTAREA', 'INPUT']\n    }\n\n    triggers() {\n        return this.collection.map(config => {\n            return config.trigger\n        })\n    }\n\n    attach(el) {\n        if (!el) {\n            throw new Error('[Tribute] Must pass in a DOM node or NodeList.')\n        }\n\n        // Check if it is a jQuery collection\n        if (typeof jQuery !== 'undefined' && el instanceof jQuery) {\n            el = el.get()\n        }\n\n        // Is el an Array/Array-like object?\n        if (el.constructor === NodeList || el.constructor === HTMLCollection || el.constructor === Array) {\n            let length = el.length\n            for (var i = 0; i < length; ++i) {\n                this._attach(el[i])\n            }\n        } else {\n            this._attach(el)\n        }\n    }\n\n    _attach(el) {\n        if (el.hasAttribute('data-tribute')) {\n            console.warn('Tribute was already bound to ' + el.nodeName)\n        }\n\n        this.ensureEditable(el)\n        this.events.bind(el)\n        el.setAttribute('data-tribute', true)\n    }\n\n    ensureEditable(element) {\n        if (Tribute.inputTypes().indexOf(element.nodeName) === -1) {\n            if (element.contentEditable) {\n                element.contentEditable = true\n            } else {\n                throw new Error('[Tribute] Cannot bind to ' + element.nodeName)\n            }\n        }\n    }\n\n    createMenu() {\n        let wrapper = this.range.getDocument().createElement('div'),\n            ul = this.range.getDocument().createElement('ul')\n\n        wrapper.className = 'tribute-container'\n        wrapper.appendChild(ul)\n\n        if (this.menuContainer) {\n            return this.menuContainer.appendChild(wrapper)\n        }\n\n        return this.range.getDocument().body.appendChild(wrapper)\n    }\n\n    showMenuFor(element, scrollTo) {\n        // Only proceed if menu isn't already shown for the current element & mentionText\n        if (this.isActive && this.current.element === element && this.current.mentionText === this.currentMentionTextSnapshot) {\n          return\n        }\n        this.currentMentionTextSnapshot = this.current.mentionText\n\n        // create the menu if it doesn't exist.\n        if (!this.menu) {\n            this.menu = this.createMenu()\n            element.tributeMenu = this.menu\n            this.menuEvents.bind(this.menu)\n        }\n\n        this.isActive = true\n        this.menuSelected = 0\n\n        if (!this.current.mentionText) {\n            this.current.mentionText = ''\n        }\n\n        const processValues = (values) => {\n            // Tribute may not be active any more by the time the value callback returns\n            if (!this.isActive) {\n                return\n            }\n\n            let items = this.search.filter(this.current.mentionText, values, {\n                pre: this.current.collection.searchOpts.pre || '<span>',\n                post: this.current.collection.searchOpts.post || '</span>',\n                skip: this.current.collection.searchOpts.skip,\n                extract: (el) => {\n                    if (typeof this.current.collection.lookup === 'string') {\n                        return el[this.current.collection.lookup]\n                    } else if (typeof this.current.collection.lookup === 'function') {\n                        return this.current.collection.lookup(el, this.current.mentionText)\n                    } else {\n                        throw new Error('Invalid lookup attribute, lookup must be string or function.')\n                    }\n                }\n            })\n\n            this.current.filteredItems = items\n\n\n            let ul = this.menu.querySelector('ul')\n\n            this.range.positionMenuAtCaret(scrollTo)\n\n            if (!items.length) {\n                let noMatchEvent = new CustomEvent('tribute-no-match', { detail: this.menu })\n                this.current.element.dispatchEvent(noMatchEvent)\n                if ( typeof this.current.collection.noMatchTemplate === 'function' && !this.current.collection.noMatchTemplate() || !this.current.collection.noMatchTemplate) {\n                    this.hideMenu()\n                } else {\n                    typeof this.current.collection.noMatchTemplate === 'function' ? ul.innerHTML = this.current.collection.noMatchTemplate() : ul.innerHTML = this.current.collection.noMatchTemplate\n                }\n\n                return\n            }\n\n            if (this.current.collection.menuItemLimit) {\n                items = items.slice(0, this.current.collection.menuItemLimit)\n            }\n\n            ul.innerHTML = ''\n            let fragment = this.range.getDocument().createDocumentFragment()\n\n            items.forEach((item, index) => {\n                let li = this.range.getDocument().createElement('li')\n                li.setAttribute('data-index', index)\n                li.addEventListener('mousemove', (e) => {\n                    let [li, index] = this._findLiTarget(e.target)\n                    if (e.movementY !== 0) {\n                        this.events.setActiveLi(index)\n                    }\n                })\n                if (this.menuSelected === index) {\n                  li.className = this.current.collection.selectClass\n                }\n                li.innerHTML = this.current.collection.menuItemTemplate(item)\n                fragment.appendChild(li)\n            })\n            ul.appendChild(fragment)\n        }\n\n        if (typeof this.current.collection.values === 'function') {\n            this.current.collection.values(this.current.mentionText, processValues)\n        } else {\n            processValues(this.current.collection.values)\n        }\n    }\n\n    _findLiTarget(el) {\n        if (!el) return []\n        const index = el.getAttribute('data-index');\n        return !index ?\n            this._findLiTarget(el.parentNode) :\n            [el, index]\n    }\n\n    showMenuForCollection(element, collectionIndex) {\n        if (element !== document.activeElement) {\n            this.placeCaretAtEnd(element)\n        }\n\n        this.current.collection = this.collection[collectionIndex || 0]\n        this.current.externalTrigger = true\n        this.current.element = element\n\n        if (element.isContentEditable)\n            this.insertTextAtCursor(this.current.collection.trigger)\n        else\n            this.insertAtCaret(element, this.current.collection.trigger)\n\n        this.showMenuFor(element)\n    }\n\n    // TODO: make sure this works for inputs/textareas\n    placeCaretAtEnd(el) {\n        el.focus();\n        if (typeof window.getSelection != \"undefined\"\n                && typeof document.createRange != \"undefined\") {\n            var range = document.createRange();\n            range.selectNodeContents(el);\n            range.collapse(false);\n            var sel = window.getSelection();\n            sel.removeAllRanges();\n            sel.addRange(range);\n        } else if (typeof document.body.createTextRange != \"undefined\") {\n            var textRange = document.body.createTextRange();\n            textRange.moveToElementText(el);\n            textRange.collapse(false);\n            textRange.select();\n        }\n    }\n\n    // for contenteditable\n    insertTextAtCursor(text) {\n        var sel, range, html;\n        sel = window.getSelection();\n        range = sel.getRangeAt(0);\n        range.deleteContents();\n        var textNode = document.createTextNode(text);\n        range.insertNode(textNode);\n        range.selectNodeContents(textNode)\n        range.collapse(false)\n        sel.removeAllRanges()\n        sel.addRange(range)\n    }\n\n    // for regular inputs\n    insertAtCaret(textarea, text) {\n        var scrollPos = textarea.scrollTop;\n        var caretPos = textarea.selectionStart;\n\n        var front = (textarea.value).substring(0, caretPos);\n        var back = (textarea.value).substring(textarea.selectionEnd, textarea.value.length);\n        textarea.value = front + text + back;\n        caretPos = caretPos + text.length;\n        textarea.selectionStart = caretPos;\n        textarea.selectionEnd = caretPos;\n        textarea.focus();\n        textarea.scrollTop = scrollPos;\n    }\n\n    hideMenu() {\n        if (this.menu) {\n            this.menu.style.cssText = 'display: none;'\n            this.isActive = false\n            this.menuSelected = 0\n            this.current = {}\n        }\n    }\n\n    selectItemAtIndex(index, originalEvent) {\n        index = parseInt(index)\n        if (typeof index !== 'number' || isNaN(index)) return\n        let item = this.current.filteredItems[index]\n        let content = this.current.collection.selectTemplate(item)\n        if (content !== null) this.replaceText(content, originalEvent, item)\n    }\n\n    replaceText(content, originalEvent, item) {\n        this.range.replaceTriggerText(content, true, true, originalEvent, item)\n    }\n\n    _append(collection, newValues, replace) {\n        if (typeof collection.values === 'function') {\n            throw new Error('Unable to append to values, as it is a function.')\n        } else if (!replace) {\n            collection.values = collection.values.concat(newValues)\n        } else {\n            collection.values = newValues\n        }\n    }\n\n    append(collectionIndex, newValues, replace) {\n        let index = parseInt(collectionIndex)\n        if (typeof index !== 'number') throw new Error('please provide an index for the collection to update.')\n\n        let collection = this.collection[index]\n\n        this._append(collection, newValues, replace)\n    }\n\n    appendCurrent(newValues, replace) {\n        if (this.isActive) {\n            this._append(this.current.collection, newValues, replace)\n        } else {\n            throw new Error('No active state. Please use append instead and pass an index.')\n        }\n    }\n\n    detach(el) {\n        if (!el) {\n            throw new Error('[Tribute] Must pass in a DOM node or NodeList.')\n        }\n\n        // Check if it is a jQuery collection\n        if (typeof jQuery !== 'undefined' && el instanceof jQuery) {\n            el = el.get()\n        }\n\n        // Is el an Array/Array-like object?\n        if (el.constructor === NodeList || el.constructor === HTMLCollection || el.constructor === Array) {\n            let length = el.length\n            for (var i = 0; i < length; ++i) {\n                this._detach(el[i])\n            }\n        } else {\n            this._detach(el)\n        }\n    }\n\n    _detach(el) {\n        this.events.unbind(el)\n        if (el.tributeMenu) {\n            this.menuEvents.unbind(el.tributeMenu)\n        }\n\n        setTimeout(() => {\n            el.removeAttribute('data-tribute')\n            this.isActive = false\n            if (el.tributeMenu) {\n                el.tributeMenu.remove()\n            }\n        })\n    }\n}\n\nexport default Tribute;\n",
    "class TributeEvents {\n    constructor(tribute) {\n        this.tribute = tribute\n        this.tribute.events = this\n    }\n\n    static keys() {\n        return [{\n            key: 9,\n            value: 'TAB'\n        }, {\n            key: 8,\n            value: 'DELETE'\n        }, {\n            key: 13,\n            value: 'ENTER'\n        }, {\n            key: 27,\n            value: 'ESCAPE'\n        }, {\n            key: 32,\n            value: 'SPACE'\n        }, {\n            key: 38,\n            value: 'UP'\n        }, {\n            key: 40,\n            value: 'DOWN'\n        }]\n    }\n\n    bind(element) {\n        element.boundKeydown = this.keydown.bind(element, this);\n        element.boundKeyup = this.keyup.bind(element, this);\n        element.boundInput = this.input.bind(element, this);\n\n        element.addEventListener('keydown',\n            element.boundKeydown, false)\n        element.addEventListener('keyup',\n            element.boundKeyup, false)\n        element.addEventListener('input',\n            element.boundInput, false)\n    }\n\n    unbind(element) {\n        element.removeEventListener('keydown',\n            element.boundKeydown, false)\n        element.removeEventListener('keyup',\n            element.boundKeyup, false)\n        element.removeEventListener('input',\n            element.boundInput, false)\n\n        delete element.boundKeydown\n        delete element.boundKeyup\n        delete element.boundInput\n    }\n\n    keydown(instance, event) {\n        if (instance.shouldDeactivate(event)) {\n            instance.tribute.isActive = false\n            instance.tribute.hideMenu()\n        }\n\n        let element = this\n        instance.commandEvent = false\n\n        TributeEvents.keys().forEach(o => {\n            if (o.key === event.keyCode) {\n                instance.commandEvent = true\n                instance.callbacks()[o.value.toLowerCase()](event, element)\n            }\n        })\n    }\n\n    input(instance, event) {\n        instance.inputEvent = true\n        instance.keyup.call(this, instance, event)\n    }\n\n    click(instance, event) {\n        let tribute = instance.tribute\n        if (tribute.menu && tribute.menu.contains(event.target)) {\n            let li = event.target\n            event.preventDefault()\n            event.stopPropagation()\n            while (li.nodeName.toLowerCase() !== 'li') {\n                li = li.parentNode\n                if (!li || li === tribute.menu) {\n                    throw new Error('cannot find the <li> container for the click')\n                }\n            }\n            tribute.selectItemAtIndex(li.getAttribute('data-index'), event)\n            tribute.hideMenu()\n\n        // TODO: should fire with externalTrigger and target is outside of menu\n        } else if (tribute.current.element && !tribute.current.externalTrigger) {\n            tribute.current.externalTrigger = false\n            setTimeout(() => tribute.hideMenu())\n        }\n    }\n\n    keyup(instance, event) {\n        if (instance.inputEvent) {\n            instance.inputEvent = false\n        }\n        instance.updateSelection(this)\n\n        if (event.keyCode === 27) return\n\n        if (!instance.tribute.allowSpaces && instance.tribute.hasTrailingSpace) {\n            instance.tribute.hasTrailingSpace = false;\n            instance.commandEvent = true;\n            instance.callbacks()[\"space\"](event, this);\n            return\n        }\n\n        if (!instance.tribute.isActive) {\n            if (instance.tribute.autocompleteMode) {\n                instance.callbacks().triggerChar(event, this, '')\n            } else {\n                let keyCode = instance.getKeyCode(instance, this, event)\n    \n                if (isNaN(keyCode) || !keyCode) return\n    \n                let trigger = instance.tribute.triggers().find(trigger => {\n                    return trigger.charCodeAt(0) === keyCode\n                })\n    \n                if (typeof trigger !== 'undefined') {\n                    instance.callbacks().triggerChar(event, this, trigger)\n                }\n            }\n        }\n\n        if ((instance.tribute.current.trigger || instance.tribute.autocompleteMode)\n            && instance.commandEvent === false\n            || instance.tribute.isActive && event.keyCode === 8) {\n          instance.tribute.showMenuFor(this, true)\n        }\n    }\n\n    shouldDeactivate(event) {\n        if (!this.tribute.isActive) return false\n\n        if (this.tribute.current.mentionText.length === 0) {\n            let eventKeyPressed = false\n            TributeEvents.keys().forEach(o => {\n                if (event.keyCode === o.key) eventKeyPressed = true\n            })\n\n            return !eventKeyPressed\n        }\n\n        return false\n    }\n\n    getKeyCode(instance, el, event) {\n        let char\n        let tribute = instance.tribute\n        let info = tribute.range.getTriggerInfo(false, tribute.hasTrailingSpace, true, tribute.allowSpaces, tribute.autocompleteMode)\n\n        if (info) {\n            return info.mentionTriggerChar.charCodeAt(0)\n        } else {\n            return false\n        }\n    }\n\n    updateSelection(el) {\n        this.tribute.current.element = el\n        let info = this.tribute.range.getTriggerInfo(false, this.tribute.hasTrailingSpace, true, this.tribute.allowSpaces, this.tribute.autocompleteMode)\n\n        if (info) {\n            this.tribute.current.selectedPath = info.mentionSelectedPath\n            this.tribute.current.mentionText = info.mentionText\n            this.tribute.current.selectedOffset = info.mentionSelectedOffset\n        }\n    }\n\n    callbacks() {\n        return {\n            triggerChar: (e, el, trigger) => {\n                let tribute = this.tribute\n                tribute.current.trigger = trigger\n\n                let collectionItem = tribute.collection.find(item => {\n                    return item.trigger === trigger\n                })\n\n                tribute.current.collection = collectionItem\n                if (tribute.inputEvent) tribute.showMenuFor(el, true)\n            },\n            enter: (e, el) => {\n                // choose selection\n                if (this.tribute.isActive && this.tribute.current.filteredItems) {\n                    e.preventDefault()\n                    e.stopPropagation()\n                    setTimeout(() => {\n                        this.tribute.selectItemAtIndex(this.tribute.menuSelected, e)\n                        this.tribute.hideMenu()\n                    }, 0)\n                }\n            },\n            escape: (e, el) => {\n                if (this.tribute.isActive) {\n                    e.preventDefault()\n                    e.stopPropagation()\n                    this.tribute.isActive = false\n                    this.tribute.hideMenu()\n                }\n            },\n            tab: (e, el) => {\n                // choose first match\n                this.callbacks().enter(e, el)\n            },\n            space: (e, el) => {\n                if (this.tribute.isActive) {\n                    if (this.tribute.spaceSelectsMatch) {\n                        this.callbacks().enter(e, el)\n                    } else if (!this.tribute.allowSpaces) {\n                        e.stopPropagation();\n                        setTimeout(() => {\n                            this.tribute.hideMenu();\n                            this.tribute.isActive = false;\n                        }, 0);\n                    }\n                }\n            },\n            up: (e, el) => {\n                // navigate up ul\n                if (this.tribute.isActive && this.tribute.current.filteredItems) {\n                    e.preventDefault()\n                    e.stopPropagation()\n                    let count = this.tribute.current.filteredItems.length,\n                        selected = this.tribute.menuSelected\n\n                    if (count > selected && selected > 0) {\n                        this.tribute.menuSelected--\n                        this.setActiveLi()\n                    } else if (selected === 0) {\n                      this.tribute.menuSelected = count - 1\n                      this.setActiveLi()\n                      this.tribute.menu.scrollTop = this.tribute.menu.scrollHeight\n                    }\n                }\n            },\n            down: (e, el) => {\n                // navigate down ul\n                if (this.tribute.isActive && this.tribute.current.filteredItems) {\n                    e.preventDefault()\n                    e.stopPropagation()\n                    let count = this.tribute.current.filteredItems.length - 1,\n                        selected = this.tribute.menuSelected\n\n                    if (count > selected) {\n                        this.tribute.menuSelected++\n                        this.setActiveLi()\n                    } else if (count === selected) {\n                        this.tribute.menuSelected = 0\n                        this.setActiveLi()\n                        this.tribute.menu.scrollTop = 0\n                    }\n                }\n            },\n            delete: (e, el) => {\n                if (this.tribute.isActive && this.tribute.current.mentionText.length < 1) {\n                    this.tribute.hideMenu()\n                } else if (this.tribute.isActive) {\n                    this.tribute.showMenuFor(el)\n                }\n            }\n        }\n    }\n\n    setActiveLi(index) {\n        let lis = this.tribute.menu.querySelectorAll('li'),\n            length = lis.length >>> 0\n\n        if (index) this.tribute.menuSelected = parseInt(index);\n\n        for (let i = 0; i < length; i++) {\n            let li = lis[i]\n            if (i === this.tribute.menuSelected) {\n                li.classList.add(this.tribute.current.collection.selectClass);\n\n                let liClientRect = li.getBoundingClientRect();\n                let menuClientRect = this.tribute.menu.getBoundingClientRect();\n\n                if (liClientRect.bottom > menuClientRect.bottom) {\n                    let scrollDistance = liClientRect.bottom - menuClientRect.bottom;\n                    this.tribute.menu.scrollTop += scrollDistance\n                } else if (liClientRect.top < menuClientRect.top) {\n                    let scrollDistance = menuClientRect.top - liClientRect.top;\n                    this.tribute.menu.scrollTop -= scrollDistance\n                }\n\n            } else {\n                li.classList.remove(this.tribute.current.collection.selectClass);\n            }\n        }\n    }\n\n    getFullHeight(elem, includeMargin) {\n      let height = elem.getBoundingClientRect().height\n\n      if (includeMargin) {\n        let style = elem.currentStyle || window.getComputedStyle(elem)\n        return height + parseFloat(style.marginTop) + parseFloat(style.marginBottom)\n      }\n\n      return height\n    }\n\n}\n\nexport default TributeEvents;\n",
    "class TributeMenuEvents {\n    constructor(tribute) {\n        this.tribute = tribute\n        this.tribute.menuEvents = this\n        this.menu = this.tribute.menu\n    }\n\n    bind(menu) {\n        this.menuClickEvent = this.tribute.events.click.bind(null, this)\n        this.menuContainerScrollEvent = this.debounce(() => {\n            if (this.tribute.isActive) {\n                this.tribute.showMenuFor(this.tribute.current.element, false)\n            }\n        }, 300, false)\n        this.windowResizeEvent = this.debounce(() => {\n            if (this.tribute.isActive) {\n                this.tribute.range.positionMenuAtCaret(true)\n            }\n        }, 300, false)\n\n        // fixes IE11 issues with mousedown\n        this.tribute.range.getDocument().addEventListener('MSPointerDown',\n            this.menuClickEvent, false)\n        this.tribute.range.getDocument().addEventListener('mousedown',\n            this.menuClickEvent, false)\n        window.addEventListener('resize', this.windowResizeEvent)\n\n        if (this.menuContainer) {\n            this.menuContainer.addEventListener('scroll', this.menuContainerScrollEvent, false)\n        } else {\n            window.addEventListener('scroll', this.menuContainerScrollEvent)\n        }\n\n    }\n\n    unbind(menu) {\n        this.tribute.range.getDocument().removeEventListener('mousedown',\n            this.menuClickEvent, false)\n        this.tribute.range.getDocument().removeEventListener('MSPointerDown',\n            this.menuClickEvent, false)\n        window.removeEventListener('resize', this.windowResizeEvent)\n\n        if (this.menuContainer) {\n            this.menuContainer.removeEventListener('scroll', this.menuContainerScrollEvent, false)\n        } else {\n            window.removeEventListener('scroll', this.menuContainerScrollEvent)\n        }\n    }\n\n    debounce(func, wait, immediate) {\n        var timeout\n        return () => {\n            var context = this,\n                args = arguments\n            var later = () => {\n                timeout = null\n                if (!immediate) func.apply(context, args)\n            }\n            var callNow = immediate && !timeout\n            clearTimeout(timeout)\n            timeout = setTimeout(later, wait)\n            if (callNow) func.apply(context, args)\n        }\n    }\n}\n\n\nexport default TributeMenuEvents;\n",
    "// Thanks to https://github.com/mattyork/fuzzy\nclass TributeSearch {\n    constructor(tribute) {\n        this.tribute = tribute\n        this.tribute.search = this\n    }\n\n    simpleFilter(pattern, array) {\n        return array.filter(string => {\n            return this.test(pattern, string)\n        })\n    }\n\n    test(pattern, string) {\n        return this.match(pattern, string) !== null\n    }\n\n    match(pattern, string, opts) {\n        opts = opts || {}\n        let patternIdx = 0,\n            result = [],\n            len = string.length,\n            totalScore = 0,\n            currScore = 0,\n            pre = opts.pre || '',\n            post = opts.post || '',\n            compareString = opts.caseSensitive && string || string.toLowerCase(),\n            ch, compareChar\n\n        if (opts.skip) {\n            return {rendered: string, score: 0}\n        }\n\n        pattern = opts.caseSensitive && pattern || pattern.toLowerCase()\n\n        let patternCache = this.traverse(compareString, pattern, 0, 0, [])\n        if (!patternCache) {\n            return null\n        }\n        return {\n            rendered: this.render(string, patternCache.cache, pre, post),\n            score: patternCache.score\n        }\n    }\n\n    traverse(string, pattern, stringIndex, patternIndex, patternCache) {\n        // if the pattern search at end\n        if (pattern.length === patternIndex) {\n\n            // calculate score and copy the cache containing the indices where it's found\n            return {\n                score: this.calculateScore(patternCache),\n                cache: patternCache.slice()\n            }\n        }\n\n        // if string at end or remaining pattern > remaining string\n        if (string.length === stringIndex || pattern.length - patternIndex > string.length - stringIndex) {\n            return undefined\n        }\n\n        let c = pattern[patternIndex]\n        let index = string.indexOf(c, stringIndex)\n        let best, temp\n\n        while (index > -1) {\n            patternCache.push(index)\n            temp = this.traverse(string, pattern, index + 1, patternIndex + 1, patternCache)\n            patternCache.pop()\n\n            // if downstream traversal failed, return best answer so far\n            if (!temp) {\n                return best\n            }\n\n            if (!best || best.score < temp.score) {\n                best = temp\n            }\n\n            index = string.indexOf(c, index + 1)\n        }\n\n        return best\n    }\n\n    calculateScore(patternCache) {\n        let score = 0\n        let temp = 1\n\n        patternCache.forEach((index, i) => {\n            if (i > 0) {\n                if (patternCache[i - 1] + 1 === index) {\n                    temp += temp + 1\n                }\n                else {\n                    temp = 1\n                }\n            }\n\n            score += temp\n        })\n\n        return score\n    }\n\n    render(string, indices, pre, post) {\n        var rendered = string.substring(0, indices[0])\n\n        indices.forEach((index, i) => {\n            rendered += pre + string[index] + post +\n                string.substring(index + 1, (indices[i + 1]) ? indices[i + 1] : string.length)\n        })\n\n        return rendered\n    }\n\n    filter(pattern, arr, opts) {\n        opts = opts || {}\n        return arr\n            .reduce((prev, element, idx, arr) => {\n                let str = element\n\n                if (opts.extract) {\n                    str = opts.extract(element)\n\n                    if (!str) { // take care of undefineds / nulls / etc.\n                        str = ''\n                    }\n                }\n\n                let rendered = this.match(pattern, str, opts)\n\n                if (rendered != null) {\n                    prev[prev.length] = {\n                        string: rendered.rendered,\n                        score: rendered.score,\n                        index: idx,\n                        original: element\n                    }\n                }\n\n                return prev\n            }, [])\n\n        .sort((a, b) => {\n            let compare = b.score - a.score\n            if (compare) return compare\n            return a.index - b.index\n        })\n    }\n}\n\nexport default TributeSearch;\n",
    "/**\n* Tribute.js\n* Native ES6 JavaScript @mention Plugin\n**/\n\nimport Tribute from \"./Tribute\";\n\nexport default Tribute;\n",
    "if (!Array.prototype.find) {\n    Array.prototype.find = function(predicate) {\n        if (this === null) {\n            throw new TypeError('Array.prototype.find called on null or undefined')\n        }\n        if (typeof predicate !== 'function') {\n            throw new TypeError('predicate must be a function')\n        }\n        var list = Object(this)\n        var length = list.length >>> 0\n        var thisArg = arguments[1]\n        var value\n\n        for (var i = 0; i < length; i++) {\n            value = list[i]\n            if (predicate.call(thisArg, value, i, list)) {\n                return value\n            }\n        }\n        return undefined\n    }\n}\n\nif (window && typeof window.CustomEvent !== \"function\") {\n  function CustomEvent(event, params) {\n    params = params || {\n      bubbles: false,\n      cancelable: false,\n      detail: undefined\n    }\n    var evt = document.createEvent('CustomEvent')\n    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail)\n    return evt\n  }\n\n if (typeof window.Event !== 'undefined') {\n   CustomEvent.prototype = window.Event.prototype\n }\n\n  window.CustomEvent = CustomEvent\n}"
  ]
}